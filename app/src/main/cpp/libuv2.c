/*
 * BSD 3-Clause License
 *
 * Copyright (c) 2025, Hancunchou@OED
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include "libuv2.h"
#include "util.h"

#define UV_PATH "/vendor/uv.bin"

static struct UVHead uvHead={
    .r=0,.g=1,.b=2,.y=3
};
int init_uv_head(void) {
  int size=0;
  FILE* fp=fopen(UV_PATH,"r");
   if(!fp){
       ALOGD("open %s failed", UV_PATH);
      return -1;
   }else{
      size = fread(&uvHead,1,sizeof(struct UVHead),fp);
      fclose(fp);
       ALOGD("open %s okay", UV_PATH);
      return 0;
   }
}

static uint16_t mask_alpha[256]={
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,0x0101,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
static uint16_t mask_w[256]={
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
};


int Rgba8888ToGrayColorWindow(char *dst_buf,char *src_buf,int rgba_buff_left,int rgba_buff_top,int rgba_buff_right,int rgba_buff_bottom,int buff_width){
    int i=0,j=0;
    int left= rgba_buff_left-(rgba_buff_left%2);
    int top= rgba_buff_top-(rgba_buff_top%2);
    int right= rgba_buff_right+(rgba_buff_right%2);
    int bottom= rgba_buff_bottom+(rgba_buff_bottom%2);
    uint32_t *pixel_0,*pixel_1;

    int dbl_width=buff_width*2;
    int div_width=buff_width/2;
    uint16_t *d0,*d1;//dst
    int idx_r=uvHead.r&0x03;
    int idx_g=uvHead.g&0x03;
    int idx_w=uvHead.y&0x03;
    int idx_b=uvHead.b&0x03;
    uint8_t p0[4] ;

    pixel_0=((uint32_t*)src_buf)+buff_width*top;//32 p
    pixel_1=pixel_0+buff_width;
    d0 = (uint16_t*) (dst_buf);
    d0+=div_width*top;
    d1 = d0 + div_width;
    uint8_t alpha=0xFF;

    for(i=top;i<bottom;i+=2, pixel_0+=dbl_width, pixel_1+=dbl_width,d0+=buff_width,d1+=buff_width){
        for(j=left;j<right;j+=2){

            *((uint32_t*)p0)= ((((pixel_0[j]>>3)&0x1F1F1F1F)+ ((pixel_0[j+1]>>3)&0x1F1F1F1F) +  ((pixel_1[j]>>3)&0x1F1F1F1F) +  ((pixel_1[j+1]>>3)&0x1F1F1F1F))<<1)&0xF8F8F8F8;
            alpha = p0[3];
            p0[3]=(p0[0]*76+(p0[1]*150)+p0[2]*30)>>8;
            p0[3] = mask_w[p0[3]];

            d0[j>>1]=mask_alpha[alpha]|(((p0[idx_r]<<5)|(p0[idx_g]>>3))&0x1E1E)|0x0040;
            d1[j>>1]=mask_alpha[alpha]|(((p0[idx_w]<<5)|(p0[idx_b]>>3))&0x1E1E)|0x80C0;

        }
    }

    return 0;
}

int Rgba8888ToGrayRgba8888Window(char *dst_buf,char *src_buf,int rgba_buff_left,int rgba_buff_top,int rgba_buff_right,int rgba_buff_bottom,int buff_width){
     int i=0,j=0;
     char *dst_pixel,*src_pixel;

     int left= rgba_buff_left;
     int right= rgba_buff_right;
     int top= rgba_buff_top;
     int bottom= rgba_buff_bottom;
     uint8_t line_bytes[] = {0x00,0x40,0x80,0xC0};
     for(i=top;i<bottom;i++){
         char *dst_pixel=dst_buf+left+i*buff_width;
         char *src_pixel=src_buf+(left+i*buff_width)*4;
         for(j=left;j<right;j++,dst_pixel++,src_pixel+=4){
             *dst_pixel=mask_alpha[src_pixel[3]]|( (((77*src_pixel[0] + 150*src_pixel[1] + 29*src_pixel[2])>>8)>>3)&0x1E) | line_bytes[ ((i&0x01)<<1)|(j&0x01)];//RGBA
         }
     }

     return 0;
}

